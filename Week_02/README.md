学习笔记：

首先对GC日志的一些名词做下解释：
项目的src/resource目录下列举了一些不同垃圾收集器的GC日志例子，其中文件名是【垃圾收集器名词+Xmx大小】下面对上面日志中出现的一些名词进行下解释：
DefNew
串行收集器：是使用-XX:+UseSerialGC (新生代、老年代都是用串行收集器)

ParNew
并行收集器：是使用-XX:+UseParNewGC (新生代使用并行收集器，老年代使用串行收集器)，或者，使用 -XX:+UseConcMarkSweepGC (新生代使用并行收集器，老年代使用CMS)

PSYoungGen
是使用-XX:+UseParallelOldGC (新生代、老年代都使用并行回收器)，或者，使用 -XX:+UseParallelGC (新生代使用并行回收器，老年代使用串行回收器)
PS指的是Parallel Scavenge,  PSYoungGen为 Eden+FromSpace， 而整个YoungGeneration为Eden+FromSpace+ToSpace

GC
表明进行一次牢记回收，前面没有Full修饰，表明这是一次Minor GC，但是它表示 不止是GC新生代，并且现有的不管是新生代还是老年代都会STW；

Allocation Failure
表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。

Full GC (Ergonomics)
这里可以看到full gc的原因是 Ergonomics ,是因为开启了自适应参数 UseAdaptiveSizePolicy，jvm自己进行自适应调整引发的full gc

tenured generation
生命周期较常的对象，归入到tenured generation。一般是经过多次minor gc，还 依旧存活的对象，将移入到tenured generation。（当然，在minor gc中如果存活的对象的超过survivor的容量，放不下的对象会直接移入到tenured generation） 
tenured generation的gc称为major gc，就是通常说的full gc。 
采用compactiion算法。由于tenured generaion区域比较大，而且通常对象生命周期都比较长，compaction需要一定时间。所以这部分的gc时间比较长。 

68864K->8575K(77440K)
垃圾收集前后的年轻代内存使用情况，其中前面的68864K为gc之前的大小，8575K为gc之后的内存大小，括号里的77440K为该内存区域的总量。
gc前 -> gc后 （总量）

[Times: user=0.00 sys=0.02, real=0.03 secs]
分别表示用户态耗时，内核态耗时和总耗时
real : 指的是操作从开始到结束所经过的墙钟时间（WallClock Time）
user : 指的是用户态消耗的CPU时间
sys : 指的是内核态消耗的CPU时间
注：墙钟时间包括各种非运算的等待耗时，例如等待磁盘IO、等待线程阻塞，而CPU时间不包括这些耗时，但是当系统有多个CPU或者多核的话，多线程操作会叠加这些CPU时间，所以看到user或sys时间超过real时间是完全正常的。 
user + sys 就是CPU花费的实际时间，注意这个值统计了所有CPU上的时间，如果进程工作在多线程的环境下，叠加了多线程的时间，这个值是会超出real所记录的值的，即 user + sys = real
如果出现几百次的real time时间大于 user+sys，表明两个问题，第一是IO操作密集，第二是CPU分配的额度不够了。


接下来以模拟串行GC oom为例，分析GC日志：



JVM参数：-Xmx128m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps
日志分析：
Minor GC分析
第一行gc日志为例：
2021-01-21T16:20:39.021+0800: [GC (Allocation Failure) 2021-01-21T16:20:39.021+0800: [DefNew: 34284K->4352K(39296K), 0.0062720 secs] 34284K->9036K(126720K), 0.0063470 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
1. 2021-01-21T16:20:39.021+0800
GC事件开始的时间点，其中+0800，表示当前时间区为东八区，这只是一个标识，方便我们直观判断GC发生的时间点

2. GC (Allocation Failure)
GC - 用来区分Minor GC 还是 Full GC的标志。没有FULL，只有GC，表明这是一次小型的GC（Minor GC），即年轻代GC，Allocation Failure 表示触发GC的原因，本次GC事件，是由于对象分配失败，年轻代中没有足够空间来存放新生代的对象引起的。

3. [DefNew: 34284K->4352K(39296K), 0.0062720 secs] 34284K->9036K(126720K), 0.0063470 secs]
DefNew - 表示垃圾收集器的名称，这个名字表示：年轻代使用单线程、标记-复制算法、STW垃圾收集器。
34284K->4352K ：表示在垃圾收集之前和之后的年轻代使用大小，
(39296K)：表示年轻代总大小。进一步分析可知：GC之后年轻代使用率为11%

4. 34284K->9036K(126720K) - 表示在垃圾收集之前和之后的整个堆内存的使用情况。(126720K) 则表示堆内存可用的总空间大小，进一步分析得知：GC之后整个堆内存使用率为7%

5. 0.0063470 secs  - GC持续的时间，单位 秒

6. [Times: user=0.01 sys=0.00, real=0.01 secs]
此次GC持续的时间，通过三个部分来衡量：user-表示所有GC线程消耗的CPU时间；sys - 表示系统调用和系统等待事件消耗的时间；real - 表示应用程序暂停的时间。
因为串行垃圾收集器（Serial Garbage Collector）只使用单个线程，所以这里的real = user + sys ,0.01秒也就是10毫秒

7. [DefNew: 34284K->4352K(39296K), 0.0062720 secs] 34284K->9036K(126720K), 0.0063470 secs]
通过上面的日志可以得出：在垃圾收集之前，堆内存总的使用量为34284K，其中年轻代也是使用了34284K，那么可以判断GC前，老年代空间的使用量为0.【实际这是GC日志中的第一条记录，后面这俩值就会有区别了】
继续分析：
GC前后对比，年轻代使用量为 34284K->4352K，减少了 29932K  ， 即 34284K - 4352K = 29932K
而堆内存的使用量为 34284K->9036K，减少了25248K，即 34284K - 9036K = 25248K
整个对内存使用量 < 年轻代使用量，说明双发的差出来的，都从年轻代提升到了老年代，
从而可以算出提升到老年代的空间为 29932K - 25248K = 4684K，当然另一组数字也可以算出来，用GC后剩余的堆内存空间减去年轻代内存空间，即 9036K - 4352K = 4684K，这两个结果是一样的。

总结：综上所述，通过分析，得出我们关注GC的日志主要关注两个数据：GC暂停时间，以及GC后的内存使用量/使用率


Full GC分析
2021-01-21T16:20:39.125+0800: [GC (Allocation Failure) 2021-01-21T16:20:39.125+0800: [DefNew: 39279K->39279K(39296K), 0.0000324 secs]2021-01-21T16:20:39.125+0800: [Tenured: 79527K->87294K(87424K), 0.0166245 secs] 118807K->90583K(126720K), [Metaspace: 3212K->3212K(1056768K)], 0.0167356 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
1. 2021-01-21T16:20:39.148+0800 - GC开始时间

2. [DefNew: 39279K->39279K(39296K), 0.0000324 secs]
由之前的分析得知，此次发生了一次年轻代GC，原因是内存分配失败，收集器同样用的是DefNew；此次GC前后年轻代的使用大小没有变化，耗时0.0000324 secs，说明这次基本上GC事件没有处理年轻代。

3. [Tenured: 79527K->87294K(87424K), 0.0166245 secs] 118807K->90583K(126720K)
Tenured - 用于清理老年代空间的垃圾收集器名称，Tenured表明使用的是单线程的STW垃圾收集器，使用标记-清除-整理(mark-sweep-compact)算法，79527K->87294K(87424K)，表示GC前后老年代的使用量，以及老年代的空间大小，0.0166245 secs 是清理老年代所花费的时间。‘

4. 118807K->90583K(126720K) - 在GC前后整个堆内存部分的使用情况，以及可用的堆内存大小。

5. [Metaspace: 3212K->3212K(1056768K)] - Metaspace 空间的变化情况，可以看出，此次GC过程中Metaspace也没变化。

6. [Times: user=0.02 sys=0.00, real=0.02 secs] 
GC事件的持续时间，串行垃圾收集器，单线程，因此real = user + sys。20毫秒的暂停时间，比前面的年轻代GC来说时间消耗增加了一倍。那这个时间和什么有关系呢？答案就是 GC时间，与GC后存活对象的总数量关系最大。

7. 进一步分析，GC后老年代的使用率为 87294K/87424K=99%，这个值相当高了，很可能为后面的oom埋下伏笔。
和年轻代相比，此次GC清理了老年代和Metaspace（虽然Metaspace没有变化）

总结：综上所述，FullGC，我们主要关注GC之后内存使用量是否下降，其次关注暂停时间。简单估算，GC后老年代使用量为85M左右，耗时20毫秒，如果内存扩大10倍，GC后老年代内存使用量也扩大10倍，那耗时可能就是500毫秒甚至更高，系统就会有明显的影响。这也是我们
经常说的串行GC弱的一个原因，所以一般服务端不会采用串行GC